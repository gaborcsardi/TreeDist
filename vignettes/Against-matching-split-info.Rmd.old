---
title: "An information-theoretic implementation of the Matching Split Distance"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: ../inst/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{#TODO remove from package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r init, echo=FALSE}
abbrevs <- c(
  rf  = 'Robinson-Foulds',
  vpi = 'Var. Phylo. Info',
  spr = 'SPR',
  path = 'Path',
  vci = 'Var. Clustering Info', 
  nts = 'Nye et al.',
  qd  = 'Quartet',
  vmsi = 'V. Mat. Split Info',
  msd = 'Mat. Split Dist'
)

vizMethods <- c(
  vpi = MutualPhylogeneticInfo,
  vmsi = MutualMatchingSplitInfo,
  vci = MutualClusteringInfo,
  nye = NyeTreeSimilarity
)

MatchTipLabels <- function (tr1, tr2) {
  tipOrder <- tr1$tip.label
  tipOrder2 <- match(tr2$tip.label, tr1$tip.label)
  tr2Tips <- tr2$edge[, 2] < 26L
  tr2$edge[tr2Tips, 2] <- tipOrder2
  tr2$tip.label <- tr1$tip.label
  tr2
}

```

## A non-arboreal Mutual Phylogenetic Information

The Mutual Phylogenetic Information measure is naturally arboreal; that is, 
an arboreal matching will always exist that is at least as optimal as any given
non-arboreal matching. 

One way to relax this effective requirement of arboreality is to adapt
the Matching Split Distance of @Bogdanowicz2012 to an information theoretic 
framework.

Two bipartitions are _congruent_ if they divide the taxa that they hold in
common into identical subsets.  For example, `a b c d e : f g h` is not congruent
with `c d : e f g`, but is congruent with `c d : f g`.

The Matching Split Distance considers the size of the largest bipartition that 
is congruent between the two bipartitons being compared, 
Y~1~ = A~1~ : B~1~; Y~2~ = A~2~ : B~2~.

An information theoretic alternative is to consider the _information content_
of the most informative congruent bipartition, which will be the most 
informative of (A~1~ ∩ A~2~, B~1~ ∩ B~2~) and (A~1~ ∩ B~2~, B~1~ ∩ A~2~).

This is implemented in the TreeDist function `MutualMatchingSplitInfo`.

## Most different pairs

```{r metric-differences-7tip, echo=FALSE, message=FALSE, fig.align='center', fig.height=7, fig.width=7, out.width='95%'}
library('TreeDist')
data("sevenTipDistances", package='TreeDistData')


tipCols <- colorspace::qualitative_hcl(7)


MostDifferent <- function (methodA, methodB)  {
  a <- as.double(sevenTipDistances[[methodA]])
  b <- as.double(sevenTipDistances[[methodB]])
  plot(b~a, pch='.', col='#00000088', 
       ylab=abbrevs[methodB], xlab=abbrevs[methodA])
  
  reg <- lm(b~a + 0)
  residualAB <- residuals(lm(b~a + 0)) / a
  residualBA <- residuals(lm(a~b + 0)) / b
  mostDiff <- head(order(sqrt(residualAB^2 + residualBA^2), decreasing = TRUE))
  abline(reg)
  text(a[mostDiff], b[mostDiff], mostDiff, pch=1, col='red')
  mostDiff
}

MostDifferent('vci', 'vmsi')
```

```{R view-metric-differences, echo=FALSE, fig.width=6, fig.height=7, out.width='95%', fig.align='center'}
par(mfrow=c(2, 2), mar = rep(1, 4))

ShowPairMatching <- function (methodA, methodB, pair) {
  if (mode(pair) == 'numeric') {
    trees <- phangorn::allTrees(7, rooted=FALSE, tip.label=letters[1:7])
    trees <- lapply(trees, ape::root, 'a', resolve.root=TRUE)
    oPair <- list(trees[[1 + (pair %/% 945)]], trees[[pair %% 945]])
  } else {
    oPair <- pair
  }
  
  tr1 <- oPair[[1]]
  tr2 <- oPair[[2]]
  VisualizeMatching(vizMethods[[methodA]], (tr1), (tr2),
                    tip.color=tipCols, setPar=FALSE)
  legend('topleft', legend=abbrevs[methodA], bty='n')
  VisualizeMatching(vizMethods[[methodB]], (tr1), (tr2),
                    tip.color=tipCols, setPar=FALSE)
  legend('topleft', legend=abbrevs[methodB], bty='n')
}

ShowPairMatching('vci', 'vmsi', 2033)

```


VPI is most different from VMSI when there exists a large clade that is similar,
but not identical, to a clade in the reference tree.  That's because VPI ignores
the match, but VMSI scores it (and sub-near-matches) highly.

```{r metric-differences, echo=FALSE, message=FALSE, fig.align='center', fig.height=7, fig.width=7, out.width='95%'}
library('TreeDist')
data("randomTreePairs25", package='TreeDistData')
data("distanceDistribution25", package='TreeDistData')
tipCols <- colorspace::qualitative_hcl(25)


MatchTipLabels <- function (tr1, tr2) {
  tipOrder <- tr1$tip.label
  tipOrder2 <- match(tr2$tip.label, tr1$tip.label)
  tr2Tips <- tr2$edge[, 2] < 26L
  tr2$edge[tr2Tips, 2] <- tipOrder2
  tr2$tip.label <- tr1$tip.label
  tr2
}

LetterTips <- function(tr) {tr$tip.label <- LETTERS[1:25]; tr}

MostDifferent <- function (methodA, methodB)  {
  a <- distanceDistribution25[methodA, ]
  b <- distanceDistribution25[methodB, ]
  plot(b~a, pch='.', col='#00000088', 
       ylab=abbrevs[methodB], xlab=abbrevs[methodA])
  
  reg <- lm(b~a)
  residualAB <- residuals(lm(b~a)) / a
  residualBA <- residuals(lm(a~b)) / b
  mostDiff <- head(order(sqrt(residualAB^2 + residualBA^2), decreasing = TRUE))
  abline(reg)
  text(a[mostDiff], b[mostDiff], mostDiff, pch=1, col='red')
}

MostDifferent('vci', 'vmsi')
```

## Ineffective MPI

```{R view-metric-differences, echo=FALSE, fig.width=6, fig.height=7, out.width='95%', fig.align='center'}
par(mfrow=c(2, 2), mar = rep(1, 4))

LetterTips <- function(tr) {tr$tip.label <- LETTERS[1:25]; tr}

ShowPairMatching <- function (methodA, methodB, pair) {
  if (mode(pair) == 'numeric') {
    oPair <- randomTreePairs25[[pair]]
  } else {
    oPair <- pair
  }
  
  tr1 <- oPair[[1]]
  tr2 <- MatchTipLabels(tr1, oPair[[2]])
  VisualizeMatching(vizMethods[[methodA]], LetterTips(tr1), LetterTips(tr2),
                    tip.color=tipCols, setPar=FALSE)
  legend('topleft', legend=abbrevs[methodA], bty='n')
  VisualizeMatching(vizMethods[[methodB]], LetterTips(tr1), LetterTips(tr2),
                    tip.color=tipCols, setPar=FALSE)
  legend('topleft', legend=abbrevs[methodB], bty='n')
}

ShowPairMatching('vci', 'vmsi', 1706)
```

```{r exdplore-1706, echo=FALSE}
library(TreeSearch)
oPair <- randomTreePairs25[[1706]]
tr1 <- oPair[[1]]
tr2 <- LetterTips(MatchTipLabels(tr1, oPair[[2]]))
tr1 <- LetterTips(tr1)
splits1 <- Tree2Splits(tr1)
splits2 <- Tree2Splits(tr2)
MutualMatchingSplitInfoSplits(splits1, splits2, reportMatching=TRUE)


```

```{R view-metric-differences-old, echo=FALSE, fig.width=6, fig.height=7, out.width='95%', fig.align='center'}
par(mfrow=c(2, 2), mar = rep(1, 4))

ShowPairMatching('vci', 'vmsi', list(ape::read.tree(text="(((t4,(((t20,t18),t3),t7)),t13),(t22,((t5,(t11,(t24,t17))),(((((((t9,t2),t23),(t12,(t14,t8))),t16),t1),(((t10,t19),t25),t6)),(t15,t21)))));"),
                 ape::read.tree(text="(((t16,t25),(((t10,((t3,(t12,t9)),t21)),t8),t6)),(t24,((t14,((t17,t18),(t22,(((t15,t7),(t19,t4)),((t23,t11),t20))))),(t5,((t13,t2),t1)))));")))

```

## References