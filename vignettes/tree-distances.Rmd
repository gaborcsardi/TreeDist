---
title: "Measuring tree distance"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: ../inst/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{Measuring tree similarity}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{R init}
methods <- c('rf', 'vai', 'spr', 'path', 'vci', 'nts', 'qd', 'msd')
abbrevs <- c(
  rf  = 'Robinson-Foulds',
  vai = 'Var. Arb Info',
  spr = 'SPR',
  path = 'Path',
  vci = 'Var. Clustering Info', 
  nts = 'Nye et al.',
  qd  = 'Quartet',
  vpi = 'Var. Partition Info',
  msd = 'Matching Splits'
)[methods]
cbPalette8 <- Ternary::cbPalette8
methodCol <- c(
'#4e78a8',
'#f28e2c',
'#e15659',
'#75b7b2',
'#58a14e',
'#edc949',
'#af7aa1',
'#fd9da7',
'#9d745f',
'#bab0ac')[1:9] # https://www.tableau.com/about/blog/2016/7/colors-upgrade-tableau-10-56782
#TreeSearch::brewer[[9]] #cbPalette8[c(1:5, 6, 7, 8, 8)]
methodPch <- c(3, 3, 6, 3, 3, 4, 4, 4, 6)
names(methodCol) <- names(methodPch) <- names(abbrevs)
methodCol <- methodCol[methods]
methodPch <- methodPch[methods]
methodLCH <- colorspace::coords(as(colorspace::hex2RGB(methodCol), 'polarLUV'))
```

## Expected tree distance of random tree pair

This figure shows how the normalized tree distance varies with the number of 
tips in the trees being compared.

Metrics marked with &#9661; are normalized based on the maximum possible value;
information-based metrics, marked +, are normalized against the total 
information content of each pair of trees; metrics marked &times; do not have a 
readily calculated maximum value and are thus normalized against the maximum 
observed distance for each number of tips.

```{R Tree-distance-averages, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1, fig.width=6, out.width='90%', fig.align='center'}

data('randomTreeDistances', package='TreeDistData')

AddLine <- function (method, normalize = FALSE) {
  dat <- randomTreeDistances[method, , ]
  if (normalize) dat <- dat / rep(randomTreeDistances[method, 'max', ], each=4)
  col <- methodCol[method]
  pch <- methodPch[method]
  nLeaves <- colnames(dat)
  #points(nLeaves, dat['mean', ], pch=pch, col=col)
  lines(nLeaves, dat['mean', ], pch=1, col=col)
  lines(nLeaves, dat['mean', ] + dat['sd', ], lty=3, col=col)
  lines(nLeaves, dat['mean', ] - dat['sd', ], lty=3, col=col)
}

plot(as.integer(dimnames(randomTreeDistances)[[3]]), 
     randomTreeDistances['vai', 'mean', ],
     ylim=c(0.4, 1), type='n',
     xlab = "Number of tips", ylab = "Normalized tree distance")
for (method in methods) AddLine(method, method %in% c('msd', 'path'))

AddLine('path', FALSE)

legend('bottomright', bty='n', pch=methodPch, lty=1,
       legend=abbrevs, 
       col=methodCol)
```


## Distribution of tree distances

```{r load-data-dists, include=FALSE}
data('distanceDistribution25', package='TreeDistData')
distanceDistribution25['rf', ] <- distanceDistribution25['rf', ] / 2L
```

The histograms below depict the distribution of tree distances for
`r dim(distanceDistribution25)[2]`
pairs of trees drawn at random from the uniform distribution.

```{R Tree-distance-distributions, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1/2, fig.width=7, out.width='90%', fig.align='center'}
par(mfrow=c(2, 4), mar=rep(1.9, 4), cex=0.8, oma=c(0, 0, 2, 0))
manyBreaks <- seq(0, 1, length.out=40)

PlotHist <- function (method, breaks) {
  hist(distanceDistribution25[method, ], xlab=NULL, main=NULL, breaks=breaks, 
       cex=0.8, border = methodCol[method])
  legend('topleft', bty='n', c('', '', abbrevs[method]), cex=0.8)
}

PlotHist('vai', manyBreaks)
mtext('Distance between random pairs of 25-tip bifurcating trees', outer=TRUE, cex=0.8)

PlotHist('vci', manyBreaks)
PlotHist('nts', manyBreaks)
PlotHist('qd',  manyBreaks)
PlotHist('msd', 40L)
PlotHist('path', 40L)
PlotHist('spr', 0:max(distanceDistribution25['spr', ]))
PlotHist('rf',  0:22)

```

## Correlation

How correlated are the measures?

```{R metric-correlation, echo=FALSE, fig.width=7, fig.height=7, out.width='95%', fig.align='center'}
par(mfrow=c(8L, 7L), mar=rep(0.2, 4))
colScale <- colorspace::sequential_hcl(1000, palette='viridis')
CorrPlot <- function (methodA, methodB) {
  a <- distanceDistribution25[methodA, ]
  b <- distanceDistribution25[methodB, ]
  plot(a~b, pch='.', col='#00000088', axes=FALSE, ylab='', xlab='')
  reg <- lm(a~b)
  #r2 <- summary(reg)$adj.r.squared
  #regCol <- colScale[max(ceiling((r2 - 0.5) * 2000), 1L)]
  abline(reg)
  #legend('bottomright', legend=paste0("RÂ² = ", signif(r2, 3)),
  #       text.col = regCol, bty='n')
}
PlotR2 <- function (methodA, methodB) {
  a <- distanceDistribution25[methodA, ]
  b <- distanceDistribution25[methodB, ]
  plot.new()
  reg <- lm(a~b)
  r2 <- summary(reg)$adj.r.squared
  regCol <- colScale[max(ceiling((r2 - 0.5) * 2000), 1L)]
  text(0.5, 0.5, signif(round(r2, 4), 3), col = regCol, cex=2.6)
}
toCorrelate <- c('vci', 'vai', 'nts', 'qd', 'msd', 'path', 'rf')
lapply(seq_along(toCorrelate), function(i)
  lapply(seq_along(toCorrelate), function(j) {
    if (i == j) {
      plot.new()
      method <- toCorrelate[i]
      text(0.5, 0.5, abbrevs[method], col=methodCol[method])
      box(which='plot', col=methodCol[method], lwd=3)
    } else if (i < j) {
      PlotR2(toCorrelate[i], toCorrelate[j])
    } else {
      CorrPlot(toCorrelate[i], toCorrelate[j])
    }
})) -> XX
lapply(toCorrelate, CorrPlot, 'spr') -> XX
mtext('SPR distance', 4L, line=-1, cex=0.7, col=methodCol['rf'])

```

## Most different pairs

```{r metric-differences, echo=FALSE, fig.width=7, fig.height=7, out.width='95%', fig.align='center'}
data("randomTreePairs25")

MatchTipLabels <- function (tr1, tr2) {
  tipOrder <- tr1$tip.label
  tipOrder2 <- match(tr2$tip.label, tr1$tip.label)
  tr2Tips <- tr2$edge[, 2] < 26L
  tr2$edge[tr2Tips, 2] <- tipOrder2
  tr2$tip.label <- tr1$tip.label
  tr2
}

LetterTips <- function(tr) {tr$tip.label <- LETTERS[1:25]; tr}


MostDifferent <- function (methodA, methodB)  {
  a <- distanceDistribution25[methodA, ]
  b <- distanceDistribution25[methodB, ]
  plot(b~a, pch='.', col='#00000088', 
       ylab=abbrevs[methodB], xlab=abbrevs[methodA])
  
  reg <- lm(b~a)
  residualAB <- residuals(lm(b~a)) / a
  residualBA <- residuals(lm(a~b)) / b
  mostDiff <- head(order(sqrt(residualAB^2 + residualBA^2), decreasing = TRUE))
  abline(reg)
  text(a[mostDiff], b[mostDiff], mostDiff, pch=1, col='red')
  tipCols <- colorspace::qualitative_hcl(25)
}

MostDifferent('vci', 'vpi')
```


As an example of why the Mutual Parition Information is not effective, see 
pairing 1, which matches `JK:` with a macro clade that contains `JK` and the 
kitchen sink.

```{R view-metric-differences, echo=FALSE, fig.width=6, fig.height=7, out.width='95%', fig.align='center'}

par(mfrow=c(2, 2), mar = rep(1, 4))

vizMethods <- c(
  vai = MutualArborealInfo,
  vpi = MutualPartitionInfo,
  vci = MutualClusteringInfo,
  nye = NyeTreeSimilarity
)

ShowPairMatching <- function (methodA, methodB, pair) {
  if (mode(pair) == 'numeric') {
    oPair <- randomTreePairs25[[pair]]
  } else {
    oPair <- pair
  }
    
  tr1 <- oPair[[1]]
  tr2 <- MatchTipLabels(tr1, oPair[[2]])
  VisualizeMatching(vizMethods[[methodA]], LetterTips(tr1), LetterTips(tr2),
                    tip.color=tipCols, setPar=FALSE)
  legend('topleft', legend=abbrevs[methodA], bty='n')
  VisualizeMatching(vizMethods[[methodB]], LetterTips(tr1), LetterTips(tr2),
                    tip.color=tipCols, setPar=FALSE)
  legend('topleft', legend=abbrevs[methodB], bty='n')
}
ape::write.tree(randomTreePairs25[[808]][[2]])

ShowPairMatching('vci', 'vpi', list(ape::read.tree(text="(((t4,(((t20,t18),t3),t7)),t13),(t22,((t5,(t11,(t24,t17))),(((((((t9,t2),t23),(t12,(t14,t8))),t16),t1),(((t10,t19),t25),t6)),(t15,t21)))));"),
                 ape::read.tree(text="(((t16,t25),(((t10,((t3,(t12,t9)),t21)),t8),t6)),(t24,((t14,((t17,t18),(t22,(((t15,t7),(t19,t4)),((t23,t11),t20))))),(t5,((t13,t2),t1)))));")))

```

## Distances between all 7-tip trees 

Inspired by @Kendall2016...

```{r 7-tip-funcs, include=FALSE} 
Palette <- function (n) colorspace::sequential_hcl(n, palette='BluYl')
MethodPalette <- function (method, n) colorspace::sequential_hcl(n,
                             h = methodLCH[method, 'H'], 
                             c = methodLCH[method, 'C'],
                             l = c(max(40, methodLCH[method, 'L']) - 30, 95),
                             power = 0.9)

data('sevenTipDistances', package='TreeDistData')
td7 <- sevenTipDistances
td7$rf <- td7$rf / 2L
treeShapes <- td7$shapes
shapes <- treeShapes[order(treeShapes)]
treeCols <- Ternary::cbPalette8[2:7]
names(treeCols) <- unique(shapes)


Hist <- function (method, breaks=32L) {
  h <- hist(td7[[method]], breaks=breaks, plot=FALSE)
  plot(h, col=MethodPalette(method, length(h$breaks)), main=abbrevs[method])
}

PlotMDS <- function(method) {
  space <- MASS::isoMDS(td7[[method]], k=2, trace=FALSE)
  pts <- space$points
  plot(pts, pch=19, col=paste0(treeCols[as.character(shapes)], '88'),
       xlab='', ylab='')
  z <- MASS::kde2d(pts[, 1], pts[, 2])
  contour(z, add=TRUE, col='#00000088')
  legend('bottomleft', legend=paste0('stress = ', signif(space$stress, 3)), bty='n')
  legend('topleft', legend=abbrevs[method], bty='n', text.font=2)
}

TableImage <- function (method) {
  x <- rep(seq_len(945), each=945L)
  y <- rep(seq_len(945), 945L)
  plot(-100, -100, type='n', ylim=c(0, 965), xlim=c(965, 0), 
       axes=FALSE, xlab='', ylab='')
  shapeSizes <- table(shapes)
  shapeSum <- cumsum(shapeSizes)
  shapeStarts <-  shapeSum - shapeSizes
  rect(shapeStarts, 950, shapeSum, 975, col=Ternary::cbPalette8[2:7], border=NA)
  rect(950, shapeStarts, 975, shapeSum, col=Ternary::cbPalette8[2:7], border=NA)

  rect(x - 1L, y - 1L, x, y, border=NA,
       col=MethodPalette(method, 100)[cut(td7[[method]], 100, labels=FALSE)])
}
```

```{r 7-tip-trees-histograms, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1, fig.width=6, out.width='90%', fig.align='center'}
par(mfrow=c(3, 3), mar=c(2.4, 0.8, 2.4, 0.8))

Hist('vai')
Hist('vci')
Hist('nts')
Hist('qd')
Hist('vpi')
Hist('msd', breaks=10)
Hist('path')
Hist('spr', breaks=3)
Hist('rf', breaks=4)
```

The coloured bars at the edges of the matrix plots correspond to the shape of 
the trees being compared, as depicted here.
```{r 7-tip-tree-shapes, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1/6, fig.width=6, out.width='90%', fig.align='center'}
par(mfrow=c(1, 6), mar=c(0, 1, 0, 1) * 0.2)

treeShapes <- c('(a, (b, (c, (d, (e, (f, g))))));',
                '(a, (b, (c, ((d, e), (f, g)))));',
                '(a, (b, ((c, d), (e, (f, g)))));',
                '(a, ((b, c), (d, (e, (f, g)))));',
                '(a, ((b, c), ((d, e), (f, g))));',
                '(a, ((b, (c, d)), (e, (f, g))));')
lapply(seq_along(treeShapes), function (i) {
  tree <- ape::read.tree(text = treeShapes[i])
  tree$edge.length <- rep(1, 12)
  plot(tree,
       edge.col=Ternary::cbPalette8[8L - i], 
       edge.width = 2L,
       show.tip.label = FALSE)
}) -> XX
```

```{r 7-tip-trees-2, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1, fig.width=6, out.width='90%', fig.align='center'}
par(mfrow=c(3, 3), mar=rep(0.8, 4))
TableImage('vai')
TableImage('vci')
TableImage('nts')
TableImage('qd')
TableImage('vpi')
TableImage('msd')
TableImage('path')
TableImage('spr')
TableImage('rf')
```

```{r 7-tip-trees-3, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1, fig.width=6, out.width='90%', fig.align='center'}
par(mfrow=c(3, 3), mar=rep(0.8, 4))

PlotMDS('vai')
PlotMDS('vci')
PlotMDS('nts')
PlotMDS('qd')
PlotMDS('vpi')
PlotMDS('msd')
PlotMDS('path')
PlotMDS('spr')
PlotMDS('rf')
```

## References
