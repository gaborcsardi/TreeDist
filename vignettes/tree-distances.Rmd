---
title: "Measuring tree distance"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: ../inst/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{Measuring tree similarity}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{R init, echo=FALSE, message=FALSE, cache=TRUE}
methods <- c('rf', 'vpi', 'sprLB', 'vci', 'msd', 'path', 'nts', 'qd')
plotSequence <- c('vpi', 'vci', 'nts', 'qd', 'msd', 'path', 'spr', 'rf')
abbrevs <- c(
  rf  = 'Robinson-Foulds',
  vpi = 'Var. Phylogenetic Info',
  spr = 'SPR, normalized against upper bound for diameter',
  sprLB = 'SPR',
  path = 'Path',
  vci = 'Var. Clustering Info', 
  nts = expression(paste(plain('Nye '), italic('et al.'))),
  qd  = 'Quartet',
  vmsi = 'Var. Matching Split Info',
  msd = 'Matching Splits'
)[methods]
methodCol <- c(
'#4e78a8',
'#f28e2c',
'#e15659',
'#75b7b2',
'#58a14e',
'#edc949',
'#af7aa1',
'#fd9da7',
'#9d745f',
'#bab0ac')[1:9] # https://www.tableau.com/about/blog/2016/7/colors-upgrade-tableau-10-56782
totalInfoContent <- 3L
maxPossible <- 6L
maxObserved <- 4L
methodPch <- c(vci = totalInfoContent, vpi = totalInfoContent, 
               rf = maxPossible, nts = maxPossible, qd = maxPossible,
               path = maxObserved, 
               msd = maxObserved)
names(methodCol) <- names(abbrevs)
methodCol <- methodCol[methods]
methodPch <- methodPch[methods]
methodLCH <- colorspace::coords(as(colorspace::hex2RGB(methodCol), 'polarLUV'))
```

## Expected tree distance of random tree pair

This figure shows how the normalized tree distance varies with the number of 
tips in the trees being compared.  1&nbsp;000 random pairs of _n_-tip trees were
generated for 4 &le; _n_ &le; 200, and the distances between them calcuated. 
Dotted envelopes denote ±1 standard deviation from the mean.

Information-based metrics, marked +, are normalized against the total 
information content of each pair of trees.

The Robinson-Fould, Nye _et al._ and Quartet Metrics (&#9661;) are normalized 
based on the maximum possible value.

The SPR distance is normalized against an upper bound of its maximum possible value,
given by _n_ - 3 [@Allen2001].

The Path and Matching Split metrics (&times;) do not have a readily calculated
maximum value and are thus crudely normalized against an approximate maximum, 
calculated by curve-fitting the maximum observed distance for each number of tips.

```{R Tree-distance-averages, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1, fig.width=6, out.width='90%', fig.align='center'}

data('randomTreeDistances', package='TreeDistData')

pathMax <- randomTreeDistances['path', 'max', ]
msdMax <- randomTreeDistances['msd', 'max', ]

nTip <- as.integer(names(pathMax))

pathNorm <- nls(pathMax ~ a * (nTip ^2) + b * (nTip ^3) + nTip ^ c,
               start = list(a = -0.034, b = 4e-5, c = 1.44))
# loess(pathMax ~ nTip) is Unsuitable for small _n_
msdNorm <- nls(msdMax ~ a * nTip + c * nTip ^ (b),
              start = list(a = -29.185, b=1.093, c = 25.390))

normalizeAgainst <- rbind(
  path = predict(pathNorm),
  msd = predict(msdNorm)
)

AddLine <- function (method, normalize = FALSE) {
  dat <- randomTreeDistances[method, , ]
  if (normalize) dat <- dat / rep(normalizeAgainst[method, ], each=4)
  col <- methodCol[method]
  pch <- methodPch[method]
  nLeaves <- colnames(dat)
  #points(nLeaves, dat['mean', ], pch=pch, col=col)
  lines(nLeaves, dat['mean', ], pch=1, col=col)
  lines(nLeaves, dat['mean', ] + dat['sd', ], lty=3, col=col)
  lines(nLeaves, dat['mean', ] - dat['sd', ], lty=3, col=col)
  pointsAt <- 1:3 * 50L
  points(pointsAt, dat['mean', as.character(pointsAt)], col=col, pch=pch)
}

plot(as.integer(dimnames(randomTreeDistances)[[3]]), 
     randomTreeDistances['vpi', 'mean', ],
     ylim=c(0.4, 1), type='n',
     xlab = "Number of tips", ylab = "Normalized tree distance")
for (method in methods) AddLine(method, method %in% c('msd', 'path'))

legend('bottomright', bty='n', pch=methodPch, lty=1,
       legend=abbrevs, 
       col=methodCol)
```

Note that the path and Matching Splits distances exhibit a prominently larger 
standard deviation than other metrics, suggesting that they are less consistent in the
score that they assign to a random pair of trees.

## Distribution of tree distances

- # TODO compare with 7-tip trees - note difference in skew for path metric!

```{r load-data-dists, include=FALSE}
data('distanceDistribution25', package='TreeDistData')
distanceDistribution25['rf', ] <- distanceDistribution25['rf', ] / 2L
```

The histograms below depict the distribution of tree distances for
`r format(dim(distanceDistribution25)[2], big.mark='&nbsp;')`
pairs of 25-tip trees drawn at random from the uniform distribution.

```{R Tree-distance-distributions, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1/2, fig.width=7, out.width='90%', fig.align='center'}
par(mfrow=c(2, 4), mar=rep(1.9, 4), cex=0.8, oma=c(0, 0, 2, 0))
manyBreaks <- seq(0, 1, length.out=40)

PlotHist <- function (method, breaks = 40L) {
  hist(distanceDistribution25[method, ], xlab=NULL, main=NULL, breaks=breaks, 
       cex=0.8, border = methodCol[method])
  legend('topleft', bty='n', c('', '', abbrevs[method]), cex=0.8)
}

PlotHist('vpi')
mtext('Distance between random pairs of 25-tip bifurcating trees', outer=TRUE, cex=0.8)

PlotHist('vci')
PlotHist('nts')
PlotHist('qd')
PlotHist('msd')
PlotHist('path')
PlotHist('spr', min(distanceDistribution25['spr', ]):max(distanceDistribution25['spr', ]))
PlotHist('rf',  min(distanceDistribution25['rf', ]):22)

```

## Correlation

The information-based metrics are highly correlated with one another, and exhibit 
strong correlation with the Nye _et al._ and Quartet metrics.  The 
Matching Splits and Path metrics are poorly correlated with all metrics except 
each other.  The Robinson-Foulds metric shows minimal correlation with any other 
metric, notwithstanding a weak correlation with the Nye _et al._ measure.

```{R metric-correlation, echo=FALSE, fig.width=7, fig.height=7, out.width='95%', fig.align='center'}
par(mfrow=c(8L, 7L), mar=rep(0.2, 4))
colScale <- colorspace::sequential_hcl(1000, palette='viridis')
CorrPlot <- function (methodA, methodB) {
  a <- distanceDistribution25[methodA, ]
  b <- distanceDistribution25[methodB, ]
  plot(a~b, pch='.', col='#00000088', axes=FALSE, ylab='', xlab='')
  reg <- lm(a~b)
  #r2 <- summary(reg)$adj.r.squared
  #regCol <- colScale[max(ceiling((r2 - 0.5) * 2000), 1L)]
  abline(reg)
  #legend('bottomright', legend=paste0("R² = ", signif(r2, 3)),
  #       text.col = regCol, bty='n')
}
PlotR2 <- function (methodA, methodB) {
  a <- distanceDistribution25[methodA, ]
  b <- distanceDistribution25[methodB, ]
  plot.new()
  reg <- lm(a~b)
  r2 <- summary(reg)$adj.r.squared
  regCol <- colScale[max(ceiling((r2 - 0.5) * 2000), 1L)]
  text(0.5, 0.5, signif(round(r2, 4), 3), col = regCol, cex=2.6)
}
toCorrelate <- c('vci', 'vpi', 'nts', 'qd', 'msd', 'path', 'rf')
lapply(seq_along(toCorrelate), function(i)
  lapply(seq_along(toCorrelate), function(j) {
    if (i == j) {
      plot.new()
      method <- toCorrelate[i]
      text(0.5, 0.5, abbrevs[method], col=methodCol[method])
      box(which='plot', col=methodCol[method], lwd=3)
    } else if (i < j) {
      PlotR2(toCorrelate[i], toCorrelate[j])
    } else {
      CorrPlot(toCorrelate[i], toCorrelate[j])
    }
})) -> XX
lapply(toCorrelate, CorrPlot, 'spr') -> XX
mtext('SPR distance', 4L, line=-1, cex=0.7, col=methodCol['spr'])

```


## References
