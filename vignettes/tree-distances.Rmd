---
title: "Measuring tree distance"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: ../inst/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{Measuring tree similarity}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{R init, echo=FALSE, message=FALSE, cache=TRUE}
methods <- c('rf', 'vai', 'spr', 'msd', 'vci', 'path', 'nts', 'qd')
plotSequence <- c('vai', 'vci', 'nts', 'qd', 'msd', 'path', 'spr', 'rf')
abbrevs <- c(
  rf  = 'Robinson-Foulds',
  vai = 'Var. Phylogenetic Info',
  spr = 'SPR',
  path = 'Path',
  vci = 'Var. Clustering Info', 
  nts = expression(paste(plain('Nye '), italic('et al.'))),
  qd  = 'Quartet',
  vpi = 'Var. Partition Info',
  msd = 'Matching Splits'
)[methods]
methodCol <- c(
'#4e78a8',
'#f28e2c',
'#e15659',
'#75b7b2',
'#58a14e',
'#edc949',
'#af7aa1',
'#fd9da7',
'#9d745f',
'#bab0ac')[1:9] # https://www.tableau.com/about/blog/2016/7/colors-upgrade-tableau-10-56782
totalInfoContent <- 3L
maxPossible <- 6L
maxObserved <- 4L
methodPch <- c(vci = totalInfoContent, vai = totalInfoContent, 
               rf = maxPossible, nts = maxPossible, qd = maxPossible,
               path = maxObserved, 
               msd = maxObserved)
names(methodCol) <- names(abbrevs)
methodCol <- methodCol[methods]
methodPch <- methodPch[methods]
methodLCH <- colorspace::coords(as(colorspace::hex2RGB(methodCol), 'polarLUV'))
```

## Expected tree distance of random tree pair

This figure shows how the normalized tree distance varies with the number of 
tips in the trees being compared.  1&nbsp;000 random pairs of _n_-tip trees were
generated for 4 &le; _n_ &le; 200, and the distances between them calcuated. 
Dotted envelopes denote ±1 standard deviation from the mean.

Information-based metrics, marked +, are normalized against the total 
information content of each pair of trees.

The Robinson-Fould, Nye _et al._ and Quartet Metrics (&#9661;) are normalized 
based on the maximum possible value.

The SPR distance is normalized against an upper bound of its maximum possible value,
given by _n_ - 3 [@Allen2001].

The Path and Matching Split metrics (&times;) do not have a readily calculated
maximum value and are thus crudely normalized against an approximate maximum, 
calculated by curve-fitting the maximum observed distance for each number of tips.

```{R Tree-distance-averages, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1, fig.width=6, out.width='90%', fig.align='center'}

data('randomTreeDistances', package='TreeDistData')

pathMax <- randomTreeDistances['path', 'max', ]
msdMax <- randomTreeDistances['msd', 'max', ]
sprMax <- randomTreeDistances['spr', 'max', ]
nTip <- as.integer(names(pathMax))

pathNorm <- nls(pathMax ~ a * (nTip ^2) + b * (nTip ^3) + nTip ^ c,
               start = list(a = -0.034, b = 4e-5, c = 1.44))
# loess(pathMax ~ nTip) is Unsuitable for small _n_
msdNorm <- nls(msdMax ~ a * nTip + c * nTip ^ (b),
              start = list(a = -14, b=1.16, c = 11.3))

normalizeAgainst <- rbind(
  path = predict(pathNorm),
  msd = predict(msdNorm)
)

AddLine <- function (method, normalize = FALSE) {
  dat <- randomTreeDistances[method, , ]
  if (normalize) dat <- dat / rep(normalizeAgainst[method, ], each=4)
  col <- methodCol[method]
  pch <- methodPch[method]
  nLeaves <- colnames(dat)
  #points(nLeaves, dat['mean', ], pch=pch, col=col)
  lines(nLeaves, dat['mean', ], pch=1, col=col)
  lines(nLeaves, dat['mean', ] + dat['sd', ], lty=3, col=col)
  lines(nLeaves, dat['mean', ] - dat['sd', ], lty=3, col=col)
}

plot(as.integer(dimnames(randomTreeDistances)[[3]]), 
     randomTreeDistances['vai', 'mean', ],
     ylim=c(0.4, 1), type='n',
     xlab = "Number of tips", ylab = "Normalized tree distance")
for (method in methods) AddLine(method, method %in% c('msd', 'path'))

legend('bottomright', bty='n', pch=methodPch, lty=1,
       legend=abbrevs, 
       col=methodCol)
```

Note that the path and Matching Splits distances exhibit a prominently larger 
standard deviation than other metrics, suggesting that they are less consistent in the
score that they assign to a random pair of trees.

## Distribution of tree distances

```{r load-data-dists, include=FALSE}
data('distanceDistribution25', package='TreeDistData')
distanceDistribution25['rf', ] <- distanceDistribution25['rf', ] / 2L
```

The histograms below depict the distribution of tree distances for
`r format(dim(distanceDistribution25)[2], big.mark='&nbsp;')`
pairs of 25-tip trees drawn at random from the uniform distribution.

```{R Tree-distance-distributions, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1/2, fig.width=7, out.width='90%', fig.align='center'}
par(mfrow=c(2, 4), mar=rep(1.9, 4), cex=0.8, oma=c(0, 0, 2, 0))
manyBreaks <- seq(0, 1, length.out=40)

PlotHist <- function (method, breaks = 40L) {
  hist(distanceDistribution25[method, ], xlab=NULL, main=NULL, breaks=breaks, 
       cex=0.8, border = methodCol[method])
  legend('topleft', bty='n', c('', '', abbrevs[method]), cex=0.8)
}

PlotHist('vai')
mtext('Distance between random pairs of 25-tip bifurcating trees', outer=TRUE, cex=0.8)

PlotHist('vci')
PlotHist('nts')
PlotHist('qd')
PlotHist('msd')
PlotHist('path')
PlotHist('spr', min(distanceDistribution25['spr', ]):max(distanceDistribution25['spr', ]))
PlotHist('rf',  min(distanceDistribution25['rf', ]):22)

```

## Correlation

The information-based metrics are highly correlated with one another, and exhibit 
strong correlation with the Nye _et al._ and Quartet metrics.  The 
Matching Splits and Path metrics are poorly correlated with all metrics except 
each other.  The Robinson-Foulds metric shows minimal correlation with any other 
metric, notwithstanding a weak correlation with the Nye _et al._ measure.

```{R metric-correlation, echo=FALSE, fig.width=7, fig.height=7, out.width='95%', fig.align='center'}
par(mfrow=c(8L, 7L), mar=rep(0.2, 4))
colScale <- colorspace::sequential_hcl(1000, palette='viridis')
CorrPlot <- function (methodA, methodB) {
  a <- distanceDistribution25[methodA, ]
  b <- distanceDistribution25[methodB, ]
  plot(a~b, pch='.', col='#00000088', axes=FALSE, ylab='', xlab='')
  reg <- lm(a~b)
  #r2 <- summary(reg)$adj.r.squared
  #regCol <- colScale[max(ceiling((r2 - 0.5) * 2000), 1L)]
  abline(reg)
  #legend('bottomright', legend=paste0("R² = ", signif(r2, 3)),
  #       text.col = regCol, bty='n')
}
PlotR2 <- function (methodA, methodB) {
  a <- distanceDistribution25[methodA, ]
  b <- distanceDistribution25[methodB, ]
  plot.new()
  reg <- lm(a~b)
  r2 <- summary(reg)$adj.r.squared
  regCol <- colScale[max(ceiling((r2 - 0.5) * 2000), 1L)]
  text(0.5, 0.5, signif(round(r2, 4), 3), col = regCol, cex=2.6)
}
toCorrelate <- c('vci', 'vai', 'nts', 'qd', 'msd', 'path', 'rf')
lapply(seq_along(toCorrelate), function(i)
  lapply(seq_along(toCorrelate), function(j) {
    if (i == j) {
      plot.new()
      method <- toCorrelate[i]
      text(0.5, 0.5, abbrevs[method], col=methodCol[method])
      box(which='plot', col=methodCol[method], lwd=3)
    } else if (i < j) {
      PlotR2(toCorrelate[i], toCorrelate[j])
    } else {
      CorrPlot(toCorrelate[i], toCorrelate[j])
    }
})) -> XX
lapply(toCorrelate, CorrPlot, 'spr') -> XX
mtext('SPR distance', 4L, line=-1, cex=0.7, col=methodCol['spr'])

```

## Distances between all 7-tip trees 

Tree distances correspond to a non-Euclidian space comprising all possible trees.
The nature of this space is difficult to visualize, but it is desirablte that
such a space is uniform and does not exhibit islands.  

@Kendall2016 evaluate tree metrics by examining the properties of the complete
tree space for all `r TreeSearch::NRooted(6)` rooted six-tip trees.  A rooted tree is equivalent to 
an unrooted tree with an additional tip added at the position of the root; as
I am considering metrics on unrooted trees, I replicate and expand the analysis 
of @Kendall2016 on all `r TreeSearch::NUnrooted(7)` unrooted seven-tip trees.

```{r 7-tip-funcs, include=FALSE} 
Palette <- function (n) colorspace::sequential_hcl(n, palette='BluYl')
MethodPalette <- function (method, n) colorspace::sequential_hcl(n,
                             h = methodLCH[method, 'H'], 
                             c = methodLCH[method, 'C'],
                             l = c(max(40, methodLCH[method, 'L']) - 30, 95),
                             power = 0.9)

data('sevenTipDistances', package='TreeDistData')
td7 <- sevenTipDistances
td7$rf <- td7$rf / 2L
treeShapes <- td7$shapes
shapes <- treeShapes[order(treeShapes)]
treeCols <- Ternary::cbPalette8[c(1:5, 8)]
names(treeCols) <- unique(shapes)


Hist <- function (method, breaks=32L) {
  h <- hist(td7[[method]], breaks=breaks, plot=FALSE)
  plot(h, col=MethodPalette(method, length(h$breaks)), main=abbrevs[method])
}

PlotMDS <- function(method) {
  space <- MASS::isoMDS(td7[[method]], k=2, trace=FALSE)
  pts <- space$points
  plot(pts, pch=19, col=paste0(treeCols[as.character(shapes)], '88'),
       xlab='', ylab='')
  z <- MASS::kde2d(pts[, 1], pts[, 2])
  contour(z, add=TRUE, col='#00000088')
  legend('bottomright', legend=paste0('stress = ', signif(space$stress, 3)), bty='n')
  legend('topleft', legend=abbrevs[method], bty='n', text.font=2)
}

TableImage <- function (method) {
  x <- rep(seq_len(945), each=945L)
  y <- rep(seq_len(945), 945L)
  plot(-100, -100, type='n', ylim=c(0, 965), xlim=c(965, 0), 
       axes=FALSE, xlab='', ylab='')
  shapeSizes <- table(shapes)
  shapeSum <- cumsum(shapeSizes)
  shapeStarts <-  shapeSum - shapeSizes
  rect(shapeStarts, 950, shapeSum, 975, col=treeCols, border=NA)
  rect(950, shapeStarts, 975, shapeSum, col=treeCols, border=NA)

  rect(x - 1L, y - 1L, x, y, border=NA,
       col=MethodPalette(method, 100)[cut(td7[[method]], 100, labels=FALSE)])
  legend('topright', legend=paste0(abbrevs[method], '  '), bty='n')
}

ClusterBars <- function(method) {
  ret <- double(length(treeCols))
  names(ret) <- names(treeCols)
  
  clusters <- cluster::pam(td7[[method]], 8L, diss=TRUE, cluster.only=TRUE)
  
  clusterShapes <- vapply(seq_len(max(clusters)), function (i) 
    table(shapes[clusters==i])[names(treeCols)],
    ret)
  
  barplot(clusterShapes, col=treeCols, main=abbrevs[method])
}
```

The first aspect to consider are the differences between each pair of 
trees.  Note that the Nye _et al._ and Quartet metrics are pectinate, in contrast
to the smooth curves of other measures.

```{r 7-tip-trees-histograms, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1/2, fig.width=6, out.width='90%', fig.align='center'}
par(mfrow=c(2, 4), mar=c(2.4, 0.8, 2.4, 0.8))

Hist('vai')
Hist('vci')
Hist('nts')
Hist('qd')
Hist('msd', breaks=10)
Hist('path')
Hist('spr', breaks=3)
Hist('rf', breaks=4)
```

The matrix plots below depict, by colour intensity, the distance between each 
pair of trees.  Rows and columns correspond to each of the `r TreeSearch::NUnrooted(7)` 
unrooted 7-tip trees, sorted according to their topology; the coloured 
bars in the margins correspond to the six distinct unlabelled tree topologies
on seven tips, as depicted below.

Note the bands in the Path distance, also evident under Matching Splits, which
indicate that high distance values are disproportionately likely when
comparing two trees of certain shapes.

```{r 7-tip-trees-2, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=2, fig.width=5, fig.align='center'}
par(mfrow=c(4, 2), mar=rep(0.8, 4))
XX <- lapply(plotSequence, TableImage)
```

```{r 7-tip-tree-shapes, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1/6, fig.width=7, out.width='90%', fig.align='center'}
par(mfrow=c(1, 6), mar=c(0, 1, 0, 1) * 0.2)

topologies <- c('(a, (b, (c, (d, (e, (f, g))))));',
                '(a, (b, (c, ((d, e), (f, g)))));',
                '(a, (b, ((c, d), (e, (f, g)))));',
                '(a, ((b, c), (d, (e, (f, g)))));',
                '(a, ((b, c), ((d, e), (f, g))));',
                '(a, ((b, (c, d)), (e, (f, g))));')

lapply(seq_along(topologies), function (i) {
  tree <- ape::read.tree(text = topologies[i])
  tree$edge.length <- rep(1, 12)
  plot(tree,
       edge.col=rev(treeCols)[i], 
       edge.width = 2L,
       show.tip.label = FALSE)
}) -> XX
```

The following figures visualize the tree spaces implied by each distance metric 
by (i) projecting the tree space into two dimensions using Kruskal's Non-Metric Multidimensional Scaling [@Cox1994]; (ii) partitioning the data into eight clusters
"around medoids" [@Reynolds2006].  Heterogeneity is evident when points are 
concentrically distributed, and when clusters are equal in size.

```{r 7-tip-trees-3, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1, fig.width=7, out.width='90%', fig.align='center'}
par(mfrow=c(4, 4), mar=rep(0.8, 4))

lapply(plotSequence[1:4], PlotMDS) -> XX
lapply(plotSequence[1:4], ClusterBars) -> XX
lapply(plotSequence[5:8], PlotMDS) -> XX
lapply(plotSequence[5:8], ClusterBars) -> XX
```

The information-based distance measures imply a heterogeneous tree space that
is largely independent of tree topology.  The Nye _et al._ and quartet metrics
are largely heterogeneous, but certain tree shapes are slightly more prone to
cluster together.  

The remaining metrics produce non-uniform tree spaces, with local aggregations;
these form particularly obvious islands in the SPR and RF distances.  Moreover,
the Matching Splits, SPR and RF distances exhibit clusters that disproportionately
contain or omit particular tree topologies, showing that the metrics reflect
tree topology more strongly than relationship information.


## References
