---
title: "Contextualizing tree distances"
author: "[Martin R. Smith](https://community.dur.ac.uk/martin.smith/)"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: ../inst/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{Contextualizing tree distances}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Once you understand [how to use _TreeDist_](Using-TreeDist.html) to calculate
tree distances, and [what distances measure](tree-distances.html), the next
step is to provide some context for the calculated distances.

## Normalizing

The maximum value of most tree distance metrics scales with the number of 
terminals in the trees being compared.
Typically, the resolution of the trees being compared also impacts the range 
of possible values.
As such, it can be difficult to interpret the tree distance value without 
suitable context. 

Normalizing a distance metric is one way to render its meaning more obvious.
The appropriate normalizing constant may consider some thought, as it will 
depend on the purpose to which a tree distance metric is being put.

The default normalization behaviour of each functions in _TreeDist_ is listed
in the accompanying manual pages, visible under the 
[function reference](reference/index.html) or by typing `?FunctionName` in the
R terminal. This default behaviour is triggered by setting `normalize = TRUE`.

### Nye tree similarity

Let's work through a simple example using the Nye _et al_. similarity metric
to compare two imperfectly-resolved trees.

```{r, fig.width=6, out.width='90%', fig.align='center'}
library('TreeDist')
tree1 <- ape::read.tree(text='(A, ((B, ((C, D), (E, F))), (G, (H, (I, J, K)))));')
tree2 <- ape::read.tree(text='(A, (B, (C, D, E, (J, K)), (G, ((H, I), F))));')
VisualizeMatching(NyeTreeSimilarity, tree1, tree2,
                  Plot=TreeDistPlot, matchZeros = FALSE)
```

This is a nice metric to start with, because the maximum similarity between 
each pair of partitions is defined as one. 
(Astute readers might worry that the minimum similarity is greater than zero --
that's a harder problem to overcome.)

As such, the maximum similarity possible between two 11-tip trees is 
[`NPartitions`](https://ms609.github.io/TreeSearch/reference/NPartitions.html)`(11)`
= `r suppressMessages(library('TreeSearch')); NPartitions(11)`.  

Normalizing against this value tells us how similar the two trees are, compared
to two identical _fully bifurcating_ eleven-tip trees; this is the default
normalization method for
[`NyeTreeSimilarity`](reference/NyeTreeSimilarity.html).

```{r}
NyeTreeSimilarity(tree1, tree2, normalize = FALSE) / 8
NyeTreeSimilarity(tree1, tree2, normalize = 8)
```

We might also be interested in comparing the tree similarity to the maximum
score possible for two trees of the specified resolution.  This value is given
by the number of partitions in the least resolved of the two trees:

```{r}
NyeTreeSimilarity(tree1, tree2, 
                  normalize = min(NPartitions(list(tree1, tree2))))
```

More concisely, we can provide a normalizing function:

```{r}
NyeTreeSimilarity(tree1, tree2, normalize = min, normalizeMax = FALSE)
```

If we are comparing lists of trees, this best value will depend on the number
of partitions in each pair of trees.  We can use the function `pmin` to 
select the less resoved of each pair of trees:


```{r}
NyeTreeSimilarity(list(tree1, tree2), list(tree1, tree2), 
                  normalize = pmin, normalizeMax = FALSE)
```


Finally, if `tree1` is a 'target' tree -- perhaps one that has been used
to simulate data from, or which is independently known to be true or virtuous --
we may wish to normalize against the best possible match to that tree.

In that case, the best possible score is 

```{r}
TreeSearch::NPartitions(tree1)
```

and our normalized score will be 

```{r}
NyeTreeSimilarity(tree1, tree2, normalize = NPartitions(tree1))
```


## Testing similarity to a known tree

This score tells us how similar the two trees are.  Similarity has two 
components: precision and accuracy.  A tree can be 80% similar to a target tree
because it contains 80% of the partitions in the target tree, and no 
incorrect partitions -- or because it is perfectly bifurcating, but 
10% of the partitions present are resolved incorrectly and are thus positively
misleading.

In such a comparison, of course, it is more sensible to talk about partition
information than just the number of partitions: an even partition may
contain more information than two very uneven partitions, so the absence of 
two information-poor partitions may be preferable to the absence of one 
information-rich partition.  As such, it is most instructive to think of the
proportion of information that has been correctly resolved: the desideratum
is that we find a tree that is as informative as possible about the true tree.

Ternary diagrams allow us to visualise the quality of a reconstructed tree
with reference to a known 'true' tree:

```{r, fig.width=6, fig.align='center', out.width='80%'}
testTrees <- list(
  trueTree = ape::read.tree(text='(a, (b, (c, (d, (e, (f, (g, h)))))));'),
  lackRes = ape::read.tree(text='(a, (b, c, (d, e, (f, g, h))));'),
  smallErr = ape::read.tree(text='(a, (c, (b, (d, (f, (e, (g, h)))))));'),
  bigErr = ape::read.tree(text='(a, (c, (((b, d), (f, h)), (e, g))));')
)
VisualizeMatching(MutualClusteringInfo, testTrees$trueTree, testTrees$lackRes)
points(4, 7.5, pch=2, cex=3, col=cbPalette8[2])
VisualizeMatching(MutualClusteringInfo, testTrees$trueTree, testTrees$smallErr)
points(4, 7.5, pch=3, cex=3, col=cbPalette8[3])
VisualizeMatching(MutualClusteringInfo, testTrees$trueTree, testTrees$bigErr)
points(4, 7.5, pch=4, cex=3, col=cbPalette8[4])
```

Better trees plot vertically towards the 'shared information' vertex. 
Resolution of trees increases towards the right; trees that are more
resolved may be no better than less-resolved trees if the addition of 
resolution introduces error.

```{r, fig.width=4, fig.align='center', fig.asp=1, out.width='50%'}
library('Ternary')
par(mar=rep(0.1, 4))
TernaryPlot(atip=NULL, btip=NULL, ctip=NULL,
            alab='Missing information', blab='Misinformation', clab='Shared information',
            lab.cex=0.8,
            lab.offset=0.18, # higher value as longer tick labels
            point='left', clockwise=FALSE,
            #col=backgroundCol,
            grid.lty='solid', grid.col='#aaaaaa',
            grid.minor.lines = 0,
            axis.labels = seq(0, 1, length.out=11L),
            axis.col="#999999",
            axis.labels.col = "black",
            ticks.length = 0.025)

HorizontalGrid()
correct <- MutualClusteringInfo(testTrees$trueTree, testTrees)
resolved <- ClusteringInfo(testTrees)
unresolved <- resolved['trueTree'] - resolved
incorrect <- resolved - correct
TernaryPoints(cbind(unresolved, incorrect, correct), 
              pch=1:4, cex=2, col=cbPalette8[1:4])
```


### Example

Here's a noddy real-world example applying this to a simulation-style study.

First, let's generate a starting tree, which will represent our reference
topology:

```{r}
set.seed(0)
library('TreeSearch')
trueTree <- ape::rtree(20)
```

Then, let's generate 100 degraded trees by making a SPR move:

```{r}
oneAway <- structure(lapply(seq_len(100), function (x) SPR(trueTree)), 
                     class='multiPhylo')
```

And let's generate 100 more trees that are even more degraded:

```{r}
twoAway <- structure(lapply(oneAway, SPR), class='multiPhylo')
```

Now let's calculate their tree similarity scores:

```{r}
correct1 <- MutualClusteringInfo(trueTree, oneAway)
resolved1 <- ClusteringInfo(oneAway)
unresolved1 <- ClusteringInfo(trueTree) - resolved1
incorrect1 <- resolved1 - correct1

correct2 <- MutualClusteringInfo(trueTree, twoAway)
resolved2 <- ClusteringInfo(twoAway)
unresolved2 <- ClusteringInfo(trueTree) - resolved2
incorrect2 <- resolved2 - correct2
```

```{r, fig.width=4, fig.align='center', fig.asp=1, out.width='50%'}
library('Ternary')
par(mar=rep(0.1, 4))
TernaryPlot(atip=NULL, btip=NULL, ctip=NULL,
            alab='Missing information', blab='Misinformation', clab='Shared information',
            lab.cex=0.8,
            lab.offset=0.18, # higher value as longer tick labels
            point='left', clockwise=FALSE,
            #col=backgroundCol,
            grid.lty='solid', grid.col='#aaaaaa',
            grid.minor.lines = 0,
            axis.labels = seq(0, 1, length.out=11L),
            axis.col="#999999",
            axis.labels.col = "black",
            ticks.length = 0.025)

HorizontalGrid()

TernaryPoints(cbind(unresolved1, incorrect1, correct1), pch='.', col='red')
TernaryPoints(cbind(unresolved2, incorrect2, correct2), pch='.', col='green')
```

## What next?

- More details of the [Ternary package](http://ms609.github.io/Ternary/)

- A summary of the [distances implemented](tree-distances.html) in TreeDist

## References
