---
title: "Contextualizing tree distances"
author: "[Martin R. Smith](https://community.dur.ac.uk/martin.smith/)"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: ../inst/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{Contextualizing tree distances}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Once you understand [how to use _TreeDist_](Using-TreeDist.html) to calculate
tree distances, and [what distances measure](tree-distances.html), the next
step is to provide some context for the calculated distances.

## Normalizing

The maximum value of most tree distance metrics scales with the number of 
terminals in the trees being compared.
Typically, the resolution of the trees being compared also impacts the range 
of possible values.
As such, it can be difficult to interpret the tree distance value without 
suitable context. 

Normalizing a distance metric is one way to render its meaning more obvious.
The appropriate normalizing constant may consider some thought, as it will 
depend on the purpose to which a tree distance metric is being put.

The default normalization behaviour of each functions in _TreeDist_ is listed
in the accompanying manual pages, visible under the 
[function reference](reference/index.html) or by typing `?FunctionName` in the
R terminal. This default behaviour is triggered by setting `normalize = TRUE`.

### Nye tree similarity

Let's work through a simple example using the Nye _et al_. similarity metric
to compare two imperfectly-resolved trees.

```{r, fig.width=6, out.width='90%', fig.align='center'}
library('TreeDist')
tree1 <- ape::read.tree(text='(A, ((B, ((C, D), (E, F))), (G, (H, (I, J, K)))));')
tree2 <- ape::read.tree(text='(A, (B, (C, D, E, (J, K)), (G, ((H, I), F))));')
VisualizeMatching(NyeTreeSimilarity, tree1, tree2,
                  Plot=TreeDistPlot, matchZeros = FALSE)
```

This is a nice metric to start with, because the maximum similarity between 
each pair of partitions is defined as one. 
(Astute readers might worry that the minimum similarity is greater than zero --
that's a harder problem to overcome.)

As such, the maximum similarity possible between two 11-tip trees is 
[`NPartitions`](https://ms609.github.io/TreeSearch/reference/NPartitions.html)`(11)`
= `r suppressMessages(library('TreeSearch')); NPartitions(11)`.  

Normalizing against this value tells us how similar the two trees are, compared
to two identical _fully bifurcating_ eleven-tip trees; this is the default
normalization method for
[`NyeTreeSimilarity`](reference/NyeTreeSimilarity.html).

```{r}
NyeTreeSimilarity(tree1, tree2, normalize = FALSE) / 8
NyeTreeSimilarity(tree1, tree2, normalize = 8)
```

We might also be interested in comparing the tree similarity to the maximum
score possible for two trees of the specified resolution.  This value is given
by the number of partitions in the least resolved of the two trees:

```{r}
NyeTreeSimilarity(tree1, tree2, 
                  normalize = min(NPartitions(list(tree1, tree2))))
```

More concisely, we can provide a normalizing function:

```{r}
NyeTreeSimilarity(tree1, tree2, normalize = min, normalizeMax = FALSE)
```

If we are comparing lists of trees, this best value will depend on the number
of partitions in each pair of trees.  We can use the function `pmin` to 
select the less resoved of each pair of trees:


```{r}
NyeTreeSimilarity(list(tree1, tree2), list(tree1, tree2), 
                  normalize = pmin, normalizeMax = FALSE)
```


Finally, if `tree1` is a 'target' tree -- perhaps one that has been used
to simulate data from, or which is independently known to be true or virtuous --
we may wish to normalize against the best possible match to that tree.

In that case, the best possible score is 

```{r}
TreeSearch::NPartitions(tree1)
```

and our normalized score will be 

```{r}
NyeTreeSimilarity(tree1, tree2, normalize = NPartitions(tree1))
```


## Testing similarity to a known tree

- The precision/accuracy distinction

- The role of information

- A ternary plotting approach

## What next?

- More details of the [Ternary package](http://ms609.github.io/Ternary/)

- A summary of the [distances implemented](tree-distances.html) in TreeDist

## References
